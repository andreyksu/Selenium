Selenium
mvn clean package
mvn alluere:server
--------------------------------------------------------
Порядок инициализации:

Test (в тесте создается WebDriver + SearcheAndAnalyzer + Page)
	> WebDriver -> SearcheAndAnalyzer(WebDriver, TimeForWait) -> ISourceProviderForBuildContainer(SearcheAndAnalyzer) - оборачивается для возможности передавать в различные Fabric.
		>  Page.PageFabric(ISourceProviderForBuildContainer)	- в Page набираются Part. Part и Page создаются через свои Fabric. Fabric -  в основном это делается для возможости возврата из Element(т.е. отложенная инициализация). Предварительно в Page или родительском Part должен быть создан ISourceProviderForBuildContainer для передачи в фабрику.
			> Part.PartFabric(ISourceProviderForBuildContainer) - где Page - как родитель.
				> PartDescritor									- Описание для Part (содержит в себе Element принадлежащие текущему Part).
					> Element 									- Описывает элементы, содержит в себе тип элемента(кнопка,ссылка), содержит конструктор генерируемого объекта(страница, LMD), Weblement

				Итак вся иерархия Part.

SearcheAndAnalyzer - инициализируется в классе BaseTestClass перед тестом (@BeforeTest) получая на вход instance WebDriver. 
	И перед каждым методом (@BeforeMethod) получает путь для сохранения артефактов теста (путь формируется исходя из названия теста и запускаемого метода) + временной префикс/постфикс.
	Стартовый путь берется из конфига (тестового конфига).
	Данный класс, так же обладает методом создания сркриншота и сохранения его в текущий каталог (текущий, что был задан в @BeforeMethod)

Еще задумка есть: У Part указывается родитель - делается это для того, что бы можно было получить от какой-то кнопки данный Part. А потом текущем Page сказать, вот тебе парт, найди его родителя и добавь к нему этот Part. Кто его родитель, спроси у этого Part - он знает.

В данной реализациие есть:
		Page - сам по себе (описывает страницу, содержит URL и вложенные Part).
		LMD - по сути тоже верхне-уровневый контейнер как и Page но без URL.
		Part - являтся кирпичиком для Page и LMD (у Part есть PartDescriptor что содержит Element-ы. Т.е. PartDescriptor является описанием для Part. Part - это то, с чем можно работать, содержит методы работы. Для Part описан так же PartRegistry - поиск элементов внтури Page ведется по PartRegistry).
				- содержит только свои методы, не содержит и не оборачивает методы за детей (т.к. набор дочерних Part для др. Page может поменяться).


Порядок добавления новых Page и Part:

Page:
	1. Создается наследник класс APageWorker
	2. В неследник PageRegistry (он должен быть один для всего приложения и может быть выполнен через Enum) добавляется описание для Page
	3. В созданный класс (наследованный от APageWorker) добавляется вложенный класс PageFabric (что является наследником от IContainerFabric<T extends IContainerWorker>).
	4. В PageFabric Выполняется инициализация создаваемого Page + добавляются вложенные Part (для добавления вложенных Part необходимо предварительно создать ISourceProviderForBuildContainer).

Part:
	1. Создается наследник класса APartWorker.
		1.1. Для создаваемого Part создается его описание. Т.е. класс унаследованный от APartDescriptor (здесь будет храниться selection самого Part и его элементов - по хорошему все пренадлежащие элменты должны находиться относительно текущего Part).
	2. В наследник PartRegistry (--//--) добавляется описание для Part (в том числе указывается родитель. Необходимо для случае если какой-то элемент будет возвращать Part - по нему можно будет понять куда добавлять возвращенный Part. Page -> getPart -> setPart).
	3. В созданный класс (наследованный от APartWorker) добавляется вложенный класс PartFabric (что является наследоником от IContainerFabric<T extends IContainerWorker>).
	4. В PartFabric производится инициализация текущего Part и дочерних, если таковые есть.

	ЗЫ.
		1. При этом набор вложенных Part определяется в родительском парт исходя из информации о корневой странице (т.е. исходя из того, какая страница является родителем).
		2. Да есть определенная сложность с формированием Part - некое усложнение. Но это компенсируется в последущем - в переиспользовании Part - т.е. Page по сути набирается из Part. И описав единыжды Part - что может повторяться от странице к странице - не нужно будет где то дублировать. Достаточно просто добавить на стринцу.
		3. Part обладает только методами, которые работают с элементами текущего Part (т.е. нет методов оберток использующих методы дочерних Part) - это обусловлено тем, что набор Part может меняться. Но можно подумать о расположении таких методов в самом Page - так как Page в отличии от Part это набор конкретных Part.
			3.1. PartDescriptor - это описание селекторов конкретного Part.
			3.2. В коллекцию внутри PartDescriptor добавляются только элементы, что должны быть обязательно проверены и без которых дальнейшая работа не возможна. Как правило это контейнеры (т.е div что содержат др. элементы). Не добавляются все Element - так как часть из них, может еще не отображаться к моменту создания страницы.
--------------------------------------------------------
Текущая реализация - это опробация модели, когда Page состоит из Part, а те в свою очередь состоят из вложенных Part. Каждый Part по сути предоставляет методы - по сути методы функциональности тех элементов, что располагается на этом Part.

Текущий подход имеет недостаток - нужно пепосредственно каждый раз искать родительский Part. После чего можно работать с текущим Part + его элементам. Бывает порой проще искать непосредстенно элемент - с корня (хотя не понятно на сколько это правильно). Если как то суммировать строки (т.е. не дублировать же стартовую часть пути во всех элементах) то так же будет сложно читать что путь имеет тек. элемент.

Да и в любом случае будет кейс, когда ищу блок а в блоке ищу набор элементов.

Но над подходом строк - можно подумать - это несколько иной подход. Т.е. идем не от Part а от PartDescriptor.
--------------------------------------------------------
Проблемы и вопросы:
В SPA кроме изменения набора Part в рамках Page - может меняться состав Element внутри Part. Подумать как быть тут?
	1.1. Пока есть решение - в Map у PartDescriptor добавлются только НЕИЗМЕНЯЕМЫЕ Element и контейнеры (что содержат другие элементы и что не изменяются при действиях со страницей), которые будут проверяться при вызвое метода isPresentAllElements. А остальные Element будут инициализироваться и вызываться по мере необходимости.
		1.1.1. Но при этом как понять какие Element инициализированы после метода isPresentAllElements а какие нужно переинициализировать перед использованием?

	1.2. Есть момент. Все Element должны искаться относительно текущего элемента Part - т.е. формирование пути только на базе String (как это сделано в PartDescriptorHeaderSecondFloor). Иначе придется делать какую-то зависимость (что будет подсказывать, относительно чего искать).
		Хотя просто так не уйти от относительного поиска. Допустим ищу блок а потом в блоке ищу элементы. Вот эти элементы длжны искаться относительно блока.

	1.3. Возможно стоит подумать как расширять PartDescriptor (допустим - есть повторяющиеся элементы у разных PartDescriptor - хотя ХЗ на сколько уже правильно если такая ситуация случилась) - так вот, можно будет сделать просто обертку над элементами другого PartDescriptor.

*** Вопрос где и как хранить список НЕнайденых элементов???? А как определять важность элементов.
*** Продумать вопрос в части перезапуска или повторного выполнения определенных методов или кейсов
		К примеру: Не смогли найти что-то выкинули исключение, наверху перехватили его и тут бы хорошо бы допустим обновить страницу и выполнить повторно.

1. Не нравится как создается Part и Page в конструкторе
	1.1. Есть повторение и дублирование одних и тех же действий и проверок (как-то нужно вынести либо в родительский класс либо в виде "Patter стратегии").
	1.2. Вообще стоит подумать над дополнительным классом (как Part и SupPart - у которого моежт быть родитель Part - см. PartRegistry). Хотя цель иная у указания родителя - это динамический поиск и размещение если какой-то элемент будет возвращать Part а не Page.
2. Сейчас у меня каждый элемент ищется относительно Part, а Part относительно верхнего Part - получается при возникновении исключения вида StaleElementReferenceException я не могу просто найти конкретный Element - мне нужно повторно найти всю цепочку Part - что довольно неудобно, хотя по логике правильно (не могу я работать с Part если нет родительского Part)
	2.1. Возможно частично решится проблема если я будут выстраивать PartDescriptor. И дочерний PartDescriptor будет получать как строку Selector родительского Part (т.е. что бы найти дочерний Part не нужно будет переискивать все вышестоящие). Но есть проблема, что на каждом уровне придется проверять а этот Part найден, а еще если селекторы разные где-то CSS а где-то XPath? Либо делать правило - что в качестве Part могут быть применены только CSS селекторы.
3. Убрать PartDescriptor в Part.
--------------------------------------------------------
Планы на разработку:
----------
*** Открываю главную страницу ---> авторизоваться ---> проверить, что авторизовались ---> найти планшет ---> открыть его ---> добавить в корзину ---> проверить что в корзине есть ---> удалить его ---> проверить что в корзине нет ---> выход ---> проверить что вышли.
*** Нужно добавить комментарии в виде JavaDoc
*** Привести то что сейчас есть к нормальному виду (причесать исключения, причесать то как сейчас логгируется. Поправить очивидные ляпы.)

--------------------------------------------------------
Задачи:
----------
1. Разобраться детальнее с фичами TestNG
	TestNG
***	Перезапуск тестов - при неуспешном выполнении предыдущего (пока не пробовал).
***	Многопоточные тесты (пока не получилось - но не особо пытался, еще вопрос про поднятые инстансы браузеров а еще работу через Docker).

2. Разобраться с фичами Selenium и Selenide и Selenoid
***	Понять что есть, как с этим работать (какие есть особенности и какие есть возможности). Допустим параметры запуска (т.е. стратегия ожидания загрузки).
		Selenide - это по сути только под Java (обертка над Selenium).

3. Сравнение элементов - визуальных (в codeceptJS - есть) - в Selenium можно по зависимостям подтянуть Sikuli.
	Sikuli: partDescriptor или Element - хранят у себя кроме cssSelector и XPath еще и визуальное представление элементов. 
			К примеру: Нашли элемент, получили его координаты, увеличили область, проверили через Sikuli нужный элемент.
--------------------------------------------------------
// xx = $x("//div[@class='main-navigation']//menu[contains(@class, 'menu_discount')]//span/a[contains(text(), ' ')]");
// xxx = xx.filter(function(item){return item.innerText.includes("ffff");})
// xx = $x("//div[@class='main-navigation']//menu[contains(@class, 'menu_discount')]//span/span[contains(., 'Сервисы и услуги')]");
-----------------
// TODO: Убрать, так как временное решение.
Actions action = new Actions(getSearcherAndAnalуzerElements().getWebDriver());
_logger.debug("Наводим мышку на элемнет!");
action.moveToElement(webElem).build().perform();
-----------------
Ушел о параметризации. В коммите 720c632b85f027a0992224fcc5761db304a16734 была параметризация.
-------------
Почему возникате ошибка, ElementWasStolen
https://nuancesprog.ru/p/9533/

-------------
Ожидание загрузки страницы:
https://sqa.stackexchange.com/questions/6588/selenium-test-case-fails-due-to-page-load-time


static void waitForPageLoad(WebDriver wdriver) {
    WebDriverWait wait = new WebDriverWait(wdriver, 60);

    Predicate<WebDriver> pageLoaded = new Predicate<WebDriver>() {

        @Override
        public boolean apply(WebDriver input) {
            return ((JavascriptExecutor) input).executeScript("return document.readyState").equals("complete");
        }

    };
    wait.until(pageLoaded);
}
